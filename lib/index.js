// Generated by CoffeeScript 2.5.1
var FieldConflictError, FieldDependencyError, ICalParser, InvalidValueError, MissingFieldError, RRule, VALID_TZ_LIST, VAlarm, VCalendar, VComponent, VDaylight, VEvent, VFreeBusy, VJournal, VStandard, VTimezone, VTodo, byline, extend, fs, helpers, iCalBuffer, moment, stream, uuid,
  indexOf = [].indexOf;

fs = require('fs');

moment = require('moment-timezone');

byline = require('byline');

stream = require('stream');

extend = require('extend');

uuid = require('uuid');

({RRule} = require('rrule'));

VALID_TZ_LIST = moment.tz.names();

({MissingFieldError, FieldConflictError, FieldDependencyError, InvalidValueError} = require('./errors'));

helpers = require('./helpers');

module.exports.decorateEvent = require('./event');

iCalBuffer = (function() {
  // Small module to generate iCal file from JS Objects or to parse iCal file
  // to obtain explicit JS Objects.

  // This module is inpired by the icalendar Python module.

    // Buffer manager to easily build long string.
  class iCalBuffer {
    addString(text) {
      return this.txt += text;
    }

    addStrings(texts) {
      var i, len, results1, text;
      results1 = [];
      for (i = 0, len = texts.length; i < len; i++) {
        text = texts[i];
        results1.push(this.addString(text));
      }
      return results1;
    }

    addLine(text) {
      return this.addString(`${text}\r\n`);
    }

    addLines(texts) {
      var i, len, results1, text;
      results1 = [];
      for (i = 0, len = texts.length; i < len; i++) {
        text = texts[i];
        results1.push(this.addLine(text));
      }
      return results1;
    }

    toString() {
      return this.txt;
    }

  };

  // TODO Make this buffer streamable
  iCalBuffer.prototype.txt = '';

  return iCalBuffer;

}).call(this);

// Base ICal Component. This class is aimed to be extended not to be used
// directly.
module.exports.VComponent = VComponent = (function() {
  class VComponent {
    constructor(options) {
      // deep clone the options
      this.model = extend(true, {}, options);
      this.subComponents = [];
      this.rawFields = [];
      // don't validate nor build automatically if no options have been passed
      // i.e. during parsing
      if (options != null) {
        this.validate();
        this.build();
      }
    }

    validate() {}

    // should be defined by subclass
    build() {
      return this.rawFields = [];
    }

    extract() {
      return this.model = {};
    }

    toString() {
      var buf;
      buf = new iCalBuffer();
      buf.addLine(`BEGIN:${this.name}`);
      this._toStringFields(buf);
      this._toStringComponents(buf);
      return buf.addString(`END:${this.name}`);
    }

    _toStringFields(buf) {
      var details, field, i, len, ref, results1;
      ref = this.rawFields;
      results1 = [];
      for (i = 0, len = ref.length; i < len; i++) {
        field = ref[i];
        details = "";
        if (typeof field.details === 'string' && field.details.length > 0) {
          details += field.details;
        } else if (field.details instanceof Array && field.details.length > 0) {
          details += ';' + field.details.join(';');
        }
        if (field.value != null) {
          results1.push(buf.addLine(`${field.key}${details}:${field.value}`));
        } else {
          results1.push(void 0);
        }
      }
      return results1;
    }

    _toStringComponents(buf) {
      var component, i, len, ref, results1;
      ref = this.subComponents;
      results1 = [];
      for (i = 0, len = ref.length; i < len; i++) {
        component = ref[i];
        results1.push(buf.addLine(component.toString()));
      }
      return results1;
    }

    add(component) {
      if (component != null) {
        return this.subComponents.push(component); // Skip invalid component
      }
    }

    walk(walker) {
      var i, len, ref, results1, sub;
      walker(this);
      ref = this.subComponents;
      results1 = [];
      for (i = 0, len = ref.length; i < len; i++) {
        sub = ref[i];
        results1.push(sub.walk(walker));
      }
      return results1;
    }

    addRawField(key, value, details = {}) {
      return this.rawFields.push({key, value, details});
    }

    addTextField(key, value, details = {}) {
      return this.addRawField(key, helpers.escapeText(value), details);
    }

    getRawField(key, findMany = false) {
      var defaultResult, field, i, len, ref;
      defaultResult = findMany ? [] : null;
      ref = this.rawFields;
      for (i = 0, len = ref.length; i < len; i++) {
        field = ref[i];
        if (field.key === key) {
          if (findMany) {
            defaultResult.push(field);
          } else {
            if (field.key) {
              return field;
            }
          }
        }
      }
      return defaultResult;
    }

    getRawValue(key, findMany = false) {
      var fields;
      fields = this.getRawField(key, findMany);
      if (findMany) {
        return fields.map(field(function() {
          return typeof field !== "undefined" && field !== null ? field.value : void 0;
        }));
      } else {
        return fields != null ? fields.value : void 0;
      }
    }

    getTextFieldValue(key, defaults) {
      var field, value;
      field = this.getRawField(key, false);
      value = helpers.unescapeText(field != null ? field.value : void 0);
      return value || defaults;
    }

  };

  VComponent.prototype.name = 'VCOMPONENT';

  VComponent.icalDTUTCFormat = 'YYYYMMDD[T]HHmmss[Z]';

  VComponent.icalDTFormat = 'YYYYMMDD[T]HHmmss';

  VComponent.icalDateFormat = 'YYYYMMDD';

  return VComponent;

}).call(this);

// Calendar component. It's the representation of the root object of a Calendar.
// @param options { organization, title }
module.exports.VCalendar = VCalendar = (function() {
  class VCalendar extends VComponent {
    constructor(options) {
      super(options);
      this.vtimezones = {};
    }

    validate() {
      if (this.model.organization == null) {
        throw new MissingFieldError('organization');
      }
      if (this.model.title == null) {
        throw new MissingFieldError('title');
      }
    }

    build() {
      var prodid;
      super.build();
      prodid = `-//${this.model.organization}//NONSGML ${this.model.title}//EN`;
      this.addRawField('VERSION', '2.0');
      this.addRawField('PRODID', prodid);
      if (this.model.method != null) {
        this.addRawField('METHOD', this.model.method);
      }
      if (this.model.name) {
        return this.addTextField('X-WR-CALNAME', this.model.name);
      }
    }

    extract() {
      var _, extractPRODID, method, name, organization, prodId, results, title, value;
      super.extract();
      prodId = this.getRawField('PRODID');
      if (prodId) {
        ({value} = prodId);
        extractPRODID = /-\/\/([\w. ]+)\/\/?(?:NONSGML )?(.+)\/\/.*/;
        results = value.match(extractPRODID);
      }
      if (results != null) {
        [_, organization, title] = results;
      } else {
        organization = 'Undefined organization';
        title = 'Undefined title';
      }
      name = this.getTextFieldValue('X-WR-CALNAME');
      method = this.getTextFieldValue('METHOD') || null;
      return this.model = {organization, title, name, method};
    }

    // VTimezone management is not included as of 18/09/2014, but code exists
    // anyway to support them if necessary in future"
    addTimezone(timezone) {
      if (this.vtimezones[timezone] == null) {
        return this.vtimezones[timezone] = new VTimezone(moment(), timezone);
      }
    }

    toString() {
      var _, buf, ref, vtimezone;
      buf = new iCalBuffer();
      buf.addLine(`BEGIN:${this.name}`);
      this._toStringFields(buf);
      ref = this.vtimezones;
      for (_ in ref) {
        vtimezone = ref[_];
        buf.addLine(vtimezone.toString());
      }
      this._toStringComponents(buf);
      return buf.addString(`END:${this.name}`);
    }

  };

  VCalendar.prototype.name = 'VCALENDAR';

  return VCalendar;

}).call(this);

// An alarm is there to warn the calendar owner of something. It could be
// included in an event or in a todo.
// REPEAT field is ommited, as Lightning don't like the REPEAT: 0 value.
// @param options { trigger, action, description, attendee, summary }
module.exports.VAlarm = VAlarm = (function() {
  class VAlarm extends VComponent {
    validate() {
      var expected;
      if (this.model.action == null) {
        throw new MissingFieldError('action');
      }
      if (this.model.trigger == null) {
        throw new MissingFieldError('trigger');
      }
      // If there is a `duration` field or a `repeat` field,
      // they must both occur
      if ((this.model.duration != null) && (this.model.repeat == null)) {
        throw new FieldDependencyError('duration', 'repeat');
      } else if ((this.model.duration == null) && (this.model.repeat != null)) {
        throw new FieldDependencyError('repeat', 'duration');
      }
      // Validates that action is in its range value
      // and specific case by action
      if (this.model.action === VAlarm.DISPLAY_ACTION) {
        if (this.model.description == null) {
          throw new MissingFieldError('description');
        }
      } else if (this.model.action === VAlarm.EMAIL_ACTION) {
        if (this.model.description == null) {
          throw new MissingFieldError('description');
        }
        if (this.model.summary == null) {
          throw new MissingFieldError('summary');
        }
        if (this.model.attendees == null) {
          throw new MissingFieldError('attendees');
        }
      } else if (this.model.action === VAlarm.AUDIO_ACTION) {

      } else {
        // nothing to be done
        expected = [VAlarm.DISPLAY_ACTION, VAlarm.EMAIL_ACTION, VAlarm.AUDIO_ACTION];
        throw new InvalidValueError('action', this.model.action, expected);
      }
    }

    build() {
      var attendee, details, fieldValue, i, len, name, ref, ref1, ref2, status;
      super.build();
      this.addRawField('ACTION', this.model.action);
      this.addRawField('TRIGGER', this.model.trigger);
      if (this.model.attendees) {
        ref = this.model.attendees;
        for (i = 0, len = ref.length; i < len; i++) {
          attendee = ref[i];
          status = ((ref1 = attendee.details) != null ? ref1.status : void 0) || 'NEEDS-ACTION';
          details = `;PARTSTAT=${status}`;
          name = ((ref2 = attendee.details) != null ? ref2.name : void 0) || attendee.email;
          details += `;CN=${name}`;
          fieldValue = `mailto:${attendee.email}`;
          this.addRawField("ATTENDEE", fieldValue, details);
        }
      }
      this.addTextField('DESCRIPTION', this.model.description);
      this.addRawField('DURATION', this.model.duration || null);
      this.addRawField('REPEAT', this.model.repeat || null);
      return this.addTextField('SUMMARY', this.model.summary);
    }

    extract() {
      var action, attendees, description, expected, ref, ref1, ref2, ref3, ref4, ref5, ref6, summary, trigger;
      super.extract();
      trigger = ((ref = this.getRawField('TRIGGER')) != null ? ref.value : void 0) || null;
      description = this.getTextFieldValue('DESCRIPTION');
      attendees = this.getRawField('ATTENDEE', true);
      attendees = attendees != null ? attendees.map(function(attendee) {
        var detail, details, email, i, key, len, name, ref1, ref2, status;
        email = attendee.value.replace('mailto:', '');
        // extracts additional values if they exist
        if (((ref1 = attendee.details) != null ? ref1.length : void 0) > 0) {
          details = {};
          ref2 = attendee.details;
          for (i = 0, len = ref2.length; i < len; i++) {
            detail = ref2[i];
            if (detail.indexOf('PARTSTAT') !== -1) {
              [key, status] = detail.split('=');
              details.status = status;
            } else if (detail.indexOf('CN') !== -1) {
              [key, name] = detail.split('=');
              details.name = name;
            }
          }
        } else {
          details = {
            status: 'NEEDS-ACTION',
            name: email
          };
        }
        return {email, details};
      }) : void 0;
      summary = this.getTextFieldValue('SUMMARY');
      expected = [VAlarm.DISPLAY_ACTION, VAlarm.EMAIL_ACTION, VAlarm.AUDIO_ACTION];
      action = (ref1 = this.getRawField('ACTION')) != null ? ref1.value : void 0;
      if (indexOf.call(expected, action) < 0) {
        action = VAlarm.DISPLAY_ACTION;
        if (description == null) {
          description = (ref2 = this.parent) != null ? ref2.getTextFieldValue('SUMMARY', '') : void 0;
        }
      // It must have mandatory fields filled based on action
      } else if (action === VAlarm.DISPLAY_ACTION) {
        if (description == null) {
          description = (ref3 = this.parent) != null ? ref3.getTextFieldValue('SUMMARY', '') : void 0;
        }
      } else if (action === VAlarm.EMAIL_ACTION) {
        if (description == null) {
          description = (ref4 = this.parent) != null ? ref4.getTextFieldValue('DESCRIPTION', '') : void 0;
        }
        if (summary == null) {
          summary = (ref5 = this.parent) != null ? ref5.getTextFieldValue('SUMMARY', '') : void 0;
        }
        if (attendees == null) {
          attendees = [];
        }
      }
      return this.model = {
        action: action,
        trigger: trigger,
        attendees: attendees,
        description: description,
        repeat: ((ref6 = this.getRawField('REPEAT')) != null ? ref6.value : void 0) || null,
        summary: summary
      };
    }

  };

  VAlarm.prototype.name = 'VALARM';

  VAlarm.EMAIL_ACTION = 'EMAIL';

  VAlarm.DISPLAY_ACTION = 'DISPLAY';

  VAlarm.AUDIO_ACTION = 'AUDIO';

  return VAlarm;

}).call(this);

// The VTodo is used to described a dated action.

// cozy's alarm use VTodo to carry VAlarm. The VTodo handle the alarm datetime
// on it's DTSTART field.
// DURATION is a fixed stubbed value of 30 minutes, to avoid infinite tasks in
// external clients (as lightning).
// Nested VAlarm ring 0 minutes after (so: at) VTodo DTSTART.
// @param options {startDate, uid, summary, description }
module.exports.VTodo = VTodo = (function() {
  class VTodo extends VComponent {
    validate() {
      if (this.model.uid == null) {
        throw new MissingFieldError('uid');
      }
      if (this.model.stampDate == null) {
        throw new MissingFieldError('stampDate');
      }
      if ((this.model.due != null) && (this.model.duration != null)) {
        throw new FieldConflictError('due', 'duration');
      }
      if ((this.model.duration != null) && (this.model.startDate == null)) {
        throw new FieldDependencyError('startDate', 'duration');
      }
    }

    build() {
      var dueDate, formattedDueDate, formattedStartDate, stampDate, startDate;
      super.build();
      // Formats stamp date to valid iCal date
      stampDate = moment.tz(this.model.stampDate, 'UTC');
      // Adds UID and DTSTAMP fields
      this.addRawField('UID', this.model.uid);
      this.addRawField('DTSTAMP', stampDate.format(VEvent.icalDTUTCFormat));
      // Formats start date if it exists
      if (this.model.startDate != null) {
        startDate = moment(this.model.startDate);
        formattedStartDate = startDate.format(VTodo.icalDTUTCFormat);
      }
      // Formats due date if it exists
      if (this.model.due != null) {
        dueDate = moment(this.model.due);
        formattedDueDate = dueDate.format(VTodo.icalDTUTCFormat);
      }
      this.addTextField('DESCRIPTION', this.model.description || null);
      this.addRawField('DTSTART', formattedStartDate || null);
      this.addRawField('DUE', formattedDueDate || null);
      this.addRawField('DURATION', this.model.duration || null);
      return this.addTextField('SUMMARY', this.model.summary || null);
    }

    extract() {
      var _, details, due, duration, ref, ref1, ref2, ref3, ref4, stampDate, startDate, timezone;
      super.extract();
      stampDate = ((ref = this.getRawField('DTSTAMP')) != null ? ref.value : void 0) || moment().tz('UTC');
      startDate = (ref1 = this.getRawField('DTSTART')) != null ? ref1.value : void 0;
      due = (ref2 = this.getRawField('DUE')) != null ? ref2.value : void 0;
      duration = (ref3 = this.getRawField('DURATION')) != null ? ref3.value : void 0;
      // Both can't exist, we remove duration
      if ((due != null) && (duration != null)) {
        duration = null;
      }
      if (startDate != null) {
        details = this.getRawField('DTSTART').details;
        if (details.length > 0) {
          [_, timezone] = details[0].split('=');
          if (indexOf.call(VALID_TZ_LIST, timezone) < 0) {
            timezone = 'UTC';
          }
        } else {
          timezone = 'UTC';
        }
        startDate = moment.tz(startDate, VTodo.icalDTUTCFormat, timezone);
      }
      if (startDate == null) {
        startDate = moment.tz(moment(), 'UTC');
      }
      return this.model = {
        uid: ((ref4 = this.getRawField('UID')) != null ? ref4.value : void 0) || uuid.v1(),
        stampDate: moment.tz(stampDate, VTodo.icalDTUTCFormat, 'UTC').toDate(),
        description: this.getTextFieldValue('DESCRIPTION', ''),
        startDate: startDate.toDate(),
        due: due,
        duration: duration,
        summary: this.getTextFieldValue('SUMMARY', ''),
        timezone: timezone
      };
    }

    // @param options { action, description, attendee, summary }
    addAlarm(options) {
      return this.add(new VAlarm(options));
    }

  };

  VTodo.prototype.name = 'VTODO';

  return VTodo;

}).call(this);

// @param options { startDate, endDate, summary, location, uid,
//                  description, allDay, rrule, timezone }
module.exports.VEvent = VEvent = (function() {
  class VEvent extends VComponent {
    validate() {
      if (this.model.uid == null) {
        throw new MissingFieldError('uid');
      }
      if (this.model.stampDate == null) {
        throw new MissingFieldError('stampDate');
      }
      if (this.model.startDate == null) {
        throw new MissingFieldError('startDate');
      }
      if ((this.model.endDate != null) && (this.model.duration != null)) {
        throw new FieldConflictError('endDate', 'duration');
      }
    }

    build() {
      var attendee, created, details, fieldEnd, fieldEndValue, fieldStart, fieldStartValue, formatEnd, formatStart, i, lastModification, len, mozLastack, name, organizer, organizerEmail, ref, ref1, ref2, ref3, rrule, stampDate, status, timezoneEnd, timezoneStart;
      super.build();
      // if there is not endDate nor duration AND not recurrence rule
      // then the default is 1 day
      if ((this.model.endDate == null) && (this.model.duration == null) && (this.model.rrule == null)) {
        this.model.endDate = moment(this.model.startDate).add(1, 'd').toDate();
      }
      // Preparing start and end dates formatting
      fieldStart = "DTSTART";
      fieldEnd = "DTEND";
      formatStart = null;
      formatEnd = null;
      // By default we have no information on timezone for each date (it's UTC)
      timezoneStart = null;
      timezoneEnd = null;
      // "all-day" event
      if (this.model.allDay) {
        // for all day event timezone information is not needed
        fieldStart += ";VALUE=DATE";
        fieldEnd += ";VALUE=DATE";
        formatStart = formatEnd = VEvent.icalDateFormat;
      // recurring event
      } else if (this.model.rrule != null) {
        // format is date-time with no trailing Z
        formatStart = formatEnd = VEvent.icalDTFormat;
        timezoneStart = timezoneEnd = this.model.timezone;
      } else {
        // if timezone is specified with options
        // punctual event
        if (this.model.timezone && this.model.timezone !== 'UTC') {
          // format is a date-time with no trailing Z
          formatStart = formatEnd = VEvent.icalDTFormat;
          timezoneStart = timezoneEnd = this.model.timezone;
        } else {
          // if so, set format and timezone name like above
          // otherwise, try to get timezone information from Date itself
          if (this.model.startDate.getTimezone != null) {
            formatStart = VEvent.icalDTFormat;
            timezoneStart = this.model.startDate.getTimezone();
          } else {
            // else format is a UTC date-time
            formatStart = VEvent.icalDTUTCFormat;
          }
          // repeat for end date ...
          if (this.model.endDate.getTimezone != null) {
            formatEnd = VEvent.icalDTFormat;
            timezoneEnd = this.model.startDate.getTimezone();
          } else {
            formatEnd = VEvent.icalDTUTCFormat;
          }
        }
      }
      if (timezoneStart != null) {
        // fields name are different if there is a timezone or not
        fieldStart += `;TZID=${timezoneStart}`;
      }
      if (timezoneEnd != null) {
        fieldEnd += `;TZID=${timezoneEnd}`;
      }
      if (this.model.rrule != null) {
        // if rrule `dtstart` property is specified, RRule outputs
        // a `dtstart` field in the rule, which is not part of the standard,
        // resulting in errors in some clients (i.e Lightning)
        delete this.model.rrule.dtstart;
        rrule = new RRule(this.model.rrule).toString();
      }
      // Formats stamp date to valid iCal date
      stampDate = moment(this.model.stampDate).tz('UTC');
      // Adds UID and DTSTAMP fields
      this.addRawField('UID', this.model.uid);
      this.addRawField('DTSTAMP', stampDate.format(VEvent.icalDTUTCFormat));
      fieldStartValue = moment(this.model.startDate).tz(timezoneStart || 'UTC');
      this.addRawField(fieldStart, fieldStartValue.format(formatStart));
      if (this.model.endDate != null) {
        fieldEndValue = moment(this.model.endDate).tz(timezoneEnd || 'UTC');
        this.addRawField(fieldEnd, fieldEndValue.format(formatEnd));
      }
      if (this.model.attendees != null) {
        ref = this.model.attendees;
        for (i = 0, len = ref.length; i < len; i++) {
          attendee = ref[i];
          status = ((ref1 = attendee.details) != null ? ref1.status : void 0) || 'NEEDS-ACTION';
          details = `;PARTSTAT=${status}`;
          name = ((ref2 = attendee.details) != null ? ref2.name : void 0) || attendee.email;
          details += `;CN=${name}`;
          this.addRawField(`ATTENDEE${details}`, `mailto:${attendee.email}`);
        }
      }
      if (this.model.lastModification != null) {
        lastModification = moment.tz(this.model.lastModification, 'UTC').format(VEvent.icalDTUTCFormat);
      }
      if (this.model.created != null) {
        created = moment.tz(this.model.created, 'UTC').format(VEvent.icalDTUTCFormat);
      }
      if (this.model.mozLastack != null) {
        mozLastack = moment.tz(this.model.mozLastack, 'UTC').format(VEvent.icalDTUTCFormat);
      }
      this.addRawField('CATEGORIES', this.model.categories || null);
      this.addRawField('CREATED', created || null);
      this.addTextField('DESCRIPTION', this.model.description || null);
      this.addRawField('DURATION', this.model.duration || null);
      this.addRawField('LAST-MODIFIED', lastModification || null);
      this.addTextField('LOCATION', this.model.location || null);
      // `@model.organizer` can be just the mandatory field (email), or an
      // object with a display name and an email.
      if (((ref3 = this.model.organizer) != null ? ref3.displayName : void 0) != null) {
        organizerEmail = this.model.organizer.email;
        details = `;CN=${this.model.organizer.displayName}`;
      } else if (this.model.organizer != null) {
        organizerEmail = this.model.organizer;
        details = "";
      }
      // Only add the field if there is an email address.
      if (organizerEmail != null) {
        organizer = `mailto:${organizerEmail}`;
        this.addRawField(`ORGANIZER${details}`, organizer || null);
      }
      this.addRawField('RRULE', rrule || null);
      this.addTextField('SUMMARY', this.model.summary || null);
      return this.addRawField('X-MOZ-LASTACK', mozLastack || null);
    }

    extract(defaultTimezone) {
      var _, allDay, attendees, created, daysNum, dtend, dtstart, duration, endDate, error, hoursNum, iCalFormat, lastModification, minutesNum, mozLastack, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, ref8, rrule, rruleOptions, secondsNum, stampDate, startDate, timezone, timezoneEnd, timezoneInfos, timezoneStart, uid, weeksNum;
      iCalFormat = 'YYYYMMDDTHHmmss';
      uid = this.getRawField('UID');
      stampDate = ((ref = this.getRawField('DTSTAMP')) != null ? ref.value : void 0) || moment();
      // gets date start and its timezone if found
      dtstart = this.getRawField('DTSTART');
      if (dtstart != null) {
        startDate = dtstart.value;
        // details for a dtstart field is timezone indicator
        if (((ref1 = dtstart.details) != null ? ref1.length : void 0) > 0) {
          if (dtstart.details[0] === 'VALUE=DATE') {
            timezoneStart = 'UTC';
            allDay = true;
          } else if (dtstart.details[0] === 'VALUE=DATE-TIME') {
            timezoneInfos = dtstart.details[1];
            if (timezoneInfos != null) {
              [_, timezoneStart] = dtstart.details[1].split('=');
              if (indexOf.call(VALID_TZ_LIST, timezoneStart) < 0) {
                timezoneStart = 'UTC';
              }
            } else {
              timezoneStart = 'UTC';
            }
          } else {
            [_, timezoneStart] = dtstart.details[0].split('=');
            if (indexOf.call(VALID_TZ_LIST, timezoneStart) < 0) {
              timezoneStart = 'UTC';
            }
          }
        } else {
          // if there is no timezone indicator, the date is in local time
          if (dtstart.value.length === 15) {
            timezoneStart = defaultTimezone; // otherwise it's UTC
          } else {
            timezoneStart = 'UTC';
          }
        }
      } else {
        startDate = moment.tz(moment(), 'UTC').format(iCalFormat);
        timezoneStart = 'UTC';
      }
      dtend = this.getRawField('DTEND');
      endDate = (dtend != null ? dtend.value : void 0) || null;
      duration = ((ref2 = this.getRawField('DURATION')) != null ? ref2.value : void 0) || null;
      // can't have both at the same time, drop duration if it's the case
      if ((endDate != null) && (duration != null)) {
        duration = null;
      // if there is none of them, fallback to default: start+1d
      } else if ((endDate == null) && (duration == null)) {
        endDate = moment.tz(startDate, iCalFormat, timezoneStart).add(1, 'd').toDate();
      // creates the end end date with the duration added to it
      } else if ((endDate == null) && (duration != null)) {
        weeksNum = helpers.iCalDurationToUnitValue(duration, 'W');
        daysNum = helpers.iCalDurationToUnitValue(duration, 'D');
        hoursNum = helpers.iCalDurationToUnitValue(duration, 'H');
        minutesNum = helpers.iCalDurationToUnitValue(duration, 'M');
        secondsNum = helpers.iCalDurationToUnitValue(duration, 'S');
        endDate = moment.tz(startDate, iCalFormat, timezoneStart);
        endDate = endDate.add(weeksNum, 'w').add(daysNum, 'd').add(hoursNum, 'h').add(minutesNum, 'm').add(secondsNum, 's').toDate();
        duration = null;
      // gets end date and its timezone if found
      } else if (endDate != null) {
        // details for a dtend field is timezone indicator
        if (((ref3 = dtend.details) != null ? ref3.length : void 0) > 0) {
          if (dtend.details[0] === 'VALUE=DATE') {
            timezoneEnd = 'UTC';
          } else if (dtend.details[0] === 'VALUE=DATE-TIME') {
            timezoneInfos = dtend.details[1];
            if (timezoneInfos != null) {
              [_, timezoneEnd] = dtend.details[1].split('=');
              if (indexOf.call(VALID_TZ_LIST, timezoneEnd) < 0) {
                timezoneEnd = 'UTC';
              }
            } else {
              timezoneEnd = 'UTC';
            }
          } else {
            [_, timezoneEnd] = dtend.details[0].split('=');
            if (indexOf.call(VALID_TZ_LIST, timezoneEnd) < 0) {
              timezoneEnd = 'UTC';
            }
          }
        } else {
          // if there is no timezone indicator, the date is in local time
          if (dtend.value.length === 15) {
            timezoneEnd = defaultTimezone; // otherwise it's UTC
          } else {
            timezoneEnd = 'UTC';
          }
        }
        endDate = moment.tz(endDate, iCalFormat, timezoneEnd).toDate();
      }
      rrule = (ref4 = this.getRawField('RRULE')) != null ? ref4.value : void 0;
      if (rrule != null) {
        if (timezoneStart !== 'UTC') {
          timezone = timezoneStart;
        }
        try {
          // Extract the until field from the rrule string.
          // Split the properties of the field.
          rrule = rrule.split(';').map(function(part) {
            var dateSection, hasZAtTheEnd, isDateTime, isUntil;
            // If it's the 'UNTIL' property.
            isUntil = part.indexOf('UNTIL') !== -1;
            if (isUntil) {
              // And if it has a DATE-TIME type, and that it
              // doesn't have a Z at the end, append it. (see #305).
              [_, dateSection] = part.split('=');
              isDateTime = dateSection.indexOf('T') !== -1;
              hasZAtTheEnd = part[part.length - 1] === 'Z';
              if (isDateTime && !hasZAtTheEnd) {
                part += 'Z';
              }
            }
            return part;
          }).filter(function(rule) {
            return rule !== '' && rule.substr(0, 5) !== 'TZID=';
          });
          if (rrule.length > 0) {
            rruleOptions = RRule.parseString(rrule.join(';'));
          }
        } catch (error1) {
          error = error1;
          console.log('RRule threw an error...');
          console.log(error);
        }
      }
      attendees = this.getRawField('ATTENDEE', true);
      attendees = attendees != null ? attendees.map(function(attendee) {
        var detail, details, email, i, key, len, name, ref5, ref6, status;
        email = attendee.value.replace('mailto:', '');
        // extracts additional values if they exist
        if (((ref5 = attendee.details) != null ? ref5.length : void 0) > 0) {
          details = {};
          ref6 = attendee.details;
          for (i = 0, len = ref6.length; i < len; i++) {
            detail = ref6[i];
            if (detail.indexOf('PARTSTAT') !== -1) {
              [key, status] = detail.split('=');
              details.status = status;
            } else if (detail.indexOf('CN') !== -1) {
              [key, name] = detail.split('=');
              details.name = name;
            }
          }
        } else {
          details = {
            status: 'NEEDS-ACTION',
            name: email
          };
        }
        return {email, details};
      }) : void 0;
      // Put back in the right format
      lastModification = (ref5 = this.getRawField('LAST-MODIFIED')) != null ? ref5.value : void 0;
      if (lastModification != null) {
        lastModification = moment.tz(lastModification, VEvent.icalDTUTCFormat, 'UTC').toISOString();
      }
      // Put back in the right format
      created = (ref6 = this.getRawField('CREATED')) != null ? ref6.value : void 0;
      if (created != null) {
        created = moment.tz(created, VEvent.icalDTUTCFormat, 'UTC').toISOString();
      }
      // Put in ISO8601 long format.
      mozLastack = this.getRawValue('X-MOZ-LASTACK');
      if (mozLastack != null) {
        mozLastack = moment.tz(mozLastack, VEvent.icalDTUTCFormat, 'UTC').toISOString();
      }
      return this.model = {
        uid: (uid != null ? uid.value : void 0) || uuid.v1(),
        stampDate: moment.tz(stampDate, VEvent.icalDTUTCFormat, 'UTC').toDate(),
        startDate: moment.tz(startDate, iCalFormat, timezoneStart).toDate(),
        endDate: endDate,
        duration: duration,
        attendees: attendees,
        categories: ((ref7 = this.getRawField('CATEGORIES')) != null ? ref7.value : void 0) || null,
        description: this.getTextFieldValue('DESCRIPTION', null),
        location: this.getTextFieldValue('LOCATION', null),
        organizer: ((ref8 = this.getRawField('ORGANIZER')) != null ? ref8.value : void 0) || null,
        rrule: rruleOptions || null,
        summary: this.getTextFieldValue('SUMMARY', null),
        allDay: allDay || null,
        timezone: timezone || null,
        lastModification: lastModification || null,
        created: created || null,
        mozLastack: mozLastack
      };
    }

  };

  VEvent.prototype.name = 'VEVENT';

  return VEvent;

}).call(this);

// @param options { startDate, timezone }
module.exports.VTimezone = VTimezone = (function() {
  class VTimezone extends VComponent {
    // constructor: (timezone) ->
    constructor(options) {
      var diff, tzurl, vdaylight, vstandard;
      super(options);
      // During parsing, VTimezone are initialized without any property,
      // so we skip the processing below
      if (!options) {
        return this;
      }
      tzurl = `http://tzurl.org/zoneinfo/${options.timezone}.ics`;
      this.rawFields = [
        {
          key: 'TZID',
          value: options.timezone
        },
        {
          key: 'TZURL',
          value: tzurl
        }
      ];
      // zone = moment.tz.zone(timezone)
      // @add new VStandard
      // startShift and endShift are equal because, actually
      // only alarm has timezone
      diff = moment.tz(options.startDate, options.timezone).format('ZZ');
      vstandard = new VStandard(options.startDate, diff, diff);
      this.add(vstandard);
      vdaylight = new VDaylight(options.startDate, diff, diff);
      this.add(vdaylight);
    }

  };

  VTimezone.prototype.name = 'VTIMEZONE';

  return VTimezone;

}).call(this);

// Additional components not supported yet by Cozy Cloud.
module.exports.VJournal = VJournal = (function() {
  class VJournal extends VComponent {};

  VJournal.prototype.name = 'VJOURNAL';

  return VJournal;

}).call(this);

module.exports.VFreeBusy = VFreeBusy = (function() {
  class VFreeBusy extends VComponent {};

  VFreeBusy.prototype.name = 'VFREEBUSY';

  return VFreeBusy;

}).call(this);

// @param options { startDate, startShift, endShift }
module.exports.VStandard = VStandard = (function() {
  class VStandard extends VComponent {
    constructor(options) {
      var dtstart;
      super(options);
      // During parsing, VStandard are initialized without any property,
      // so we skip the processing below
      if (!options) {
        return this;
      }
      dtstart = moment(options.startDate).format(VStandard.icalDTFormat);
      this.rawFields = [
        {
          key: 'DTSTART',
          value: dtstart
        },
        {
          key: 'TZOFFSETFROM',
          value: options.startShift
        },
        {
          key: 'TZOFFSETTO',
          value: options.endShift
        }
      ];
    }

  };

  VStandard.prototype.name = 'STANDARD';

  return VStandard;

}).call(this);

// @param options { startDate, startShift, endShift }
module.exports.VDaylight = VDaylight = (function() {
  class VDaylight extends VComponent {
    constructor(options) {
      var dtstart;
      super(options);
      // During parsing, VDaylight are initialized without any property,
      // so we skip the processing below
      if (!options) {
        return this;
      }
      dtstart = moment(options.startDate).format(VDaylight.icalDTFormat);
      this.rawFields = [
        {
          key: 'DTSTART',
          value: dtstart
        },
        {
          key: 'TZOFFSETFROM',
          value: options.startShift
        },
        {
          key: 'TZOFFSETTO',
          value: options.endShift
        }
      ];
    }

  };

  VDaylight.prototype.name = 'DAYLIGHT';

  return VDaylight;

}).call(this);

module.exports.ICalParser = ICalParser = (function() {
  class ICalParser {
    parseFile(file, options, callback) {
      // optional 'options' parameter
      if (arguments.length < 3) {
        callback = options;
        this.defaultTimezone = 'UTC';
      } else {
        this.defaultTimezone = options.defaultTimezone || 'UTC';
      }
      return this.parse(fs.createReadStream(file), callback);
    }

    parseString(string, options, callback) {
      var fakeStream;
      // optional 'options' parameter
      if (arguments.length < 3) {
        callback = options;
        this.defaultTimezone = 'UTC';
      } else {
        this.defaultTimezone = options.defaultTimezone || 'UTC';
      }
      fakeStream = new stream.Readable();
      fakeStream._read = function() {};
      this.parse(fakeStream, callback);
      fakeStream.push(string);
      return fakeStream.push(null);
    }

    parse(stream, callback) {
      var completeLine, component, createComponent, lineNumber, lineParser, noerror, parent, result, sendError;
      stream = byline(stream);
      result = {};
      noerror = true;
      lineNumber = 0;
      component = null;
      parent = null;
      completeLine = null;
      stream.on('end', function() {
        if (completeLine) {
          lineParser(completeLine);
        }
        if (noerror) {
          return callback(null, result);
        }
      });
      sendError = function(msg) {
        if (noerror) {
          callback(new Error(`${msg} (line ${lineNumber})`));
        }
        return noerror = false;
      };
      createComponent = function(name) {
        parent = component;
        if (name === "VCALENDAR") {
          if (result.fields != null) {
            sendError("Cannot parse more than one calendar");
          }
          component = new VCalendar();
          result = component;
        } else if (indexOf.call(Object.keys(ICalParser.components), name) >= 0) {
          component = new ICalParser.components[name]();
        } else {
          sendError(`Malformed ical file, unknown component ${name}`);
        }
        if (component != null) {
          component.parent = parent;
        }
        return parent != null ? parent.add(component) : void 0;
      };
      lineParser = (line) => {
        var detail, details, err, i, key, len, pname, pvalue, results1, tuple, value;
        // Fix for #47 : encode quoted string to prevent
        // some characters lik : or , to make the parsing fail
        line = line.replace(/"([^"]+)"/g, function(str) {
          return encodeURIComponent(str);
        });
        tuple = line.trim().split(':');
        if (tuple.length < 2) {
          err = "Malformed ical file: missing ':'";
          console.log(err);
          console.log(line);
          return sendError(err);
        } else {
          // Decode quoted strings
          key = tuple.shift().replace(/"([^"]+)"/g, function(str) {
            return decodeURIComponent(str);
          });
          value = tuple.join(':');
          if (key === "BEGIN") {
            return createComponent(value);
          } else if (key === "END") {
            component.extract(this.defaultTimezone);
            return component = component.parent;
          } else if (!((component != null) || (result != null))) {
            err = "Malformed ical file: no component nor result";
            console.log(err);
            console.log(line);
            return sendError(err);
          } else if ((key != null) && key !== '' && (component != null)) {
            [key, ...details] = key.split(';');
            component.addRawField(key, value, details);
            results1 = [];
            for (i = 0, len = details.length; i < len; i++) {
              detail = details[i];
              results1.push([pname, pvalue] = detail.split('='));
            }
            return results1;
          } else {
            err = "Malformed ical file";
            console.log(err);
            console.log(line);
            return sendError(err);
          }
        }
      };
      return stream.on('data', function(line) {
        stream.pause();
        lineNumber++;
        line = line.toString('utf-8').replace("\r", '');
        // Skip blank lines and a strange behaviour :
        // empty lines become <Buffer 30> which is '0' .
        if (line === '' || line === '0') {
          return stream.resume();
        }
        if (/^\s/.test(line[0])) {
          completeLine += line.replace(/^\s+/, '');
        } else {
          if (completeLine) {
            lineParser(completeLine);
          }
          completeLine = line;
        }
        return stream.resume();
      });
    }

  };

  ICalParser.components = {
    VTODO: VTodo,
    VALARM: VAlarm,
    VEVENT: VEvent,
    VJOURNAL: VJournal,
    VFREEBUSY: VFreeBusy,
    VTIMEZONE: VTimezone,
    STANDARD: VStandard,
    DAYLIGHT: VDaylight
  };

  return ICalParser;

}).call(this);
