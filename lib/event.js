// Generated by CoffeeScript 2.5.1
var RRule, moment;

moment = require('moment-timezone');

({RRule} = require('rrule'));

module.exports = function(Event) {
  var VAlarm, VCalendar, VEvent;
  ({VCalendar, VEvent, VAlarm} = require('./index'));
  // Return VEvent object or undefined if mandatory elements miss.
  Event.prototype.toIcal = function(timezone = 'UTC') {
    var allDay, created, e, event, lastModification, mappedAttendees, ref, ref1, rrule, stampDate;
    allDay = this.start.length === 10;
    // Recurring events must be in local timezone.
    if (this.rrule) {
      if (this.timezone != null) {
        timezone = this.timezone;
      } else if (!allDay) {
        console.log("Recurring events need timezone.");
      }
      // some events, imported from an external source, have a wrong RRUle,
      // with a TZID, so we need to filter them
      this.rrule = this.rrule.split(';').filter(function(rule) {
        return rule !== '' && rule.substr(0, 5) !== 'TZID=';
      }).join(';');
      if (this.rrule.length === 0) {
        this.rrule = null;
      }
    }
    timezone = this.timezone || timezone;
    rrule = this.rrule != null ? RRule.parseString(this.rrule) : null;
    mappedAttendees = (ref = this.attendees) != null ? ref.map(function(attendee) {
      return {
        email: attendee.email,
        status: attendee.status
      };
    }) : void 0;
    created = this.created || null;
    lastModification = this.lastModification || null;
    stampDate = this.lastModification || moment().tz('UTC');
    stampDate = moment.tz(stampDate, 'UTC').toDate();
    try {
      event = new VEvent({
        stampDate: stampDate,
        startDate: moment.tz(this.start, timezone),
        endDate: moment.tz(this.end, timezone),
        summary: this.description,
        location: this.place,
        uid: this.uid || this.id,
        description: this.details,
        allDay: allDay,
        rrule: rrule,
        attendees: mappedAttendees,
        timezone: timezone,
        created: created,
        lastModification: lastModification,
        mozLastack: this.mozLastack
      });
    } catch (error) {
      e = error;
      console.log('Can\'t parse event mandatory fields.');
      console.log(e);
      return void 0; // all those elements are mandatory.
    }
    if ((ref1 = this.alarms) != null) {
      ref1.forEach((alarm) => {
        var ref2, ref3;
        if ((ref2 = alarm.action) === VAlarm.DISPLAY_ACTION || ref2 === 'BOTH') {
          event.add(new VAlarm({
            trigger: alarm.trigg,
            action: VAlarm.DISPLAY_ACTION,
            description: this.description
          }));
        }
        if (((ref3 = alarm.action) === VAlarm.EMAIL_ACTION || ref3 === 'BOTH') && (this.getAlarmAttendeesEmail != null)) {
          mappedAttendees = this.getAlarmAttendeesEmail().map(function(email) {
            return {
              email: email,
              status: 'ACCEPTED'
            };
          });
          return event.add(new VAlarm({
            trigger: alarm.trigg,
            action: VAlarm.EMAIL_ACTION,
            summary: this.description,
            description: this.details || '',
            attendees: mappedAttendees
          }));
        }
      });
    }
    // else : ignore other actions.
    return event;
  };
  // Return a valid Event object, or undefined.
  Event.fromIcal = function(vevent, defaultCalendar = 'my calendar') {
    var alarms, defaultCozyStatus, end, event, model, now, ref, ref1, ref2, stampDate, start, timezone;
    event = new Event();
    ({model} = vevent);
    now = moment().tz('UTC').toISOString();
    timezone = model.timezone || 'UTC';
    if (model.uid != null) {
      event.id = model.uid;
    }
    if (model.uid != null) {
      event.uid = model.uid;
    }
    event.description = model.summary || '';
    event.details = model.description || '';
    event.place = model.location;
    if ((ref = model.rrule) != null) {
      delete ref.bynmonthday;
    }
    if ((ref1 = model.rrule) != null) {
      delete ref1.bynweekday;
    }
    event.rrule = new RRule(model.rrule).toString();
    defaultCozyStatus = 'INVITATION-NOT-SENT';
    event.attendees = (ref2 = model.attendees) != null ? ref2.map(function(attendee, index) {
      var contactid, email, id, ref3, status;
      status = ((ref3 = attendee.details) != null ? ref3.status : void 0) || defaultCozyStatus;
      if (status === 'NEEDS-ACTION') {
        status = defaultCozyStatus;
      }
      email = attendee.email;
      id = index + 1;
      contactid = null;
      return {id, email, contactid, status};
    }) : void 0;
    if (model.created != null) {
      event.created = model.created;
    }
    stampDate = moment.tz(model.stampDate, 'UTC').toISOString();
    event.lastModification = model.lastModification || stampDate || now;
    event.mozLastack = model.mozLastack;
    if (model.allDay) {
      event.start = moment.tz(model.startDate, 'UTC').format(Event.dateFormat);
      event.end = moment.tz(model.endDate, 'UTC').format(Event.dateFormat);
    } else {
      if (timezone !== 'UTC') {
        start = moment.tz(model.startDate, timezone);
        end = moment.tz(model.endDate, timezone);
      } else {
        start = moment.tz(model.startDate, 'UTC');
        end = moment.tz(model.endDate, 'UTC');
      }
      // Format, only RRule doesn't use UTC
      if (model.rrule != null) {
        event.timezone = timezone;
        event.start = start.format(Event.ambiguousDTFormat);
        event.end = end.format(Event.ambiguousDTFormat);
      } else {
        event.start = start.toISOString();
        event.end = end.toISOString();
      }
    }
    // Alarms reminders.
    alarms = [];
    vevent.subComponents.forEach(function(component) {
      var action, alarmModel, trigg;
      if (component.name === !'VALARM') {
        return;
      }
      alarmModel = component.model;
      trigg = alarmModel.trigger;
      action = alarmModel.action;
      if (trigg && trigg.match(Event.alarmTriggRegex)) {
        return alarms.push({
          trigg: trigg,
          action: action
        });
      }
    });
    if (alarms) {
      event.alarms = alarms;
    }
    event.tags = [defaultCalendar];
    return event;
  };
  return Event.extractEvents = function(component, defaultCalendar = 'my calendar') {
    var events;
    events = [];
    component.walk(function(component) {
      if (component.name === 'VEVENT') {
        return events.push(Event.fromIcal(component, defaultCalendar));
      }
    });
    return events;
  };
};
